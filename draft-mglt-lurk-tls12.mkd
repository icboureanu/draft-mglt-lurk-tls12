---
title: LURK Extension version 1 for (D)TLS 1.2 Authentication
abbrev: LURK/TLS 1.2 
docname: draft-mglt-lurk-tls12


area: Security
wg: LURK
kw: Internet-Draft
cat: std

coding: us-ascii
pi:
  rfcedstyle: yes
  toc: yes
  tocindent: yes
  sortrefs: yes
  symrefs: yes
  strict: yes
  comments: yes
  inline: yes
  docmapping: yes

author:
      -
        ins: D. Migault
        name: Daniel Migault
        org: Ericsson
        street: 8275 Trans Canada Route
        city: Saint Laurent, QC
        code: 4S 0B6
        country: Canada
        email: daniel.migault@ericsson.com
	
	ins: I. Boureanu
        name: Ioana Boureanu
        org: University of Surrey
        street: Stag Hill Campus
        city: Guildford, UK
        code: GU2 7XH
        country: United Kingdom
        email: ioana.boureanu@surrey.ac.uk


--- abstract

This document describes the LURK Extension 'tls12' which enables
interactions between a LURK Client and a LURK Server in a context of
authentication with (D)TLS 1.2.

--- middle


# Introduction {#sec-intro}

This document describes the LURK Extension for TLS 1.2 so the LURK
Server can implement a Cryptographic Service in a TLS 1.2 {{!RFC5246}}
and DTLS 1.2 {{!RFC6347}} context.

More specifically, the LURK Server will be in charge of performing the
cryptographic operations associated to the private key of the TLS
Server, while other aspects of the termination of the TLS session is
handled by other services in the same administrative domain or in a
different administrative domain. Most Cryptographic Operations are
related to the TLS authentication and the current document limits the
Cryptographic Operations to the following authentication methods: RSA
and ECDHE_RSA defined in {{!RFC5246}}, {{!RFC6347}} as well as
ECDHE_ECDSA defined in {{!I-D.ietf-tls-rfc4492bis}}.

A more detailed description of some use cases foreseen in a TLS context
can be found in {{?I-D.mglt-lurk-tls-use-cases}}.

HTTPS delegation has been the main concern of the Content Delivery
Networks Interconnection (cdni) Working Group and  several mechanisms
have been designed to delegate the load from an upstream entity to a
downstream entity. Entities can be of different nature and may
designated differently according to the context. Typically designations
includes Content Owner, CDN Provider, Domain Name Owner for example.
{{?I-D.fieau-cdni-https-delegation}} provides a details comparison of
the various mechanisms applies to the CDN Interconnection, and the
remaining of this section positions these mechanisms at a very high
level view.

STAR {{?I-D.ietf-acme-star}}, {{?I-D.sheffer-acme-star-request}}
describes a methods where the domain name owner or the content owner
orchestrates the refreshing process between a CA and the CDN
(terminating the TLS session). The CDN refreshes regularly and
automatically its certificates using {{?I-D.ietf-acme-acme}}, which
allows the use of short term certificates.

Delegated credentials {{?I-D.rescorla-tls-subcerts}} consists having a
certificate that enables the servers to generates some "delegated
credentials".

STAR and "delegated credentials" both require some changes performed by
the CA - new certificate type for the delegated credentials and new
interfaces for the delegated and delegating entity for STAR. In both
case the TLS Client authenticates the delegated entity. While STAR does
not require changes on the TLS Client, the "delegated credential"
solution does. In both cases, the delegation is controlled by limiting
in time (7 days), which is also the limit of use of a stolen key or a
rogue server. Such delegation provides a high scalability of the
architecture and prevents additional delays when a TLS session is
established. 

The LURK Architecture {{?I-D.mglt-lurk-lurk}} and the LURK Extension
'tls12' do not proceed to the delegation of the HTTPS delegation by
delegating the entire TLS termination. Instead, the TLS termination is
split into sub services, for example one associated to the networking
part and one associated to the cryptographic operation. While micro
services associated to the networking part are delegated, the micro
service associated to the cryptographic operation may not be delegated.
As a result, LURK Architecture is focused on the protection of the
Cryptographic Material and prevents leakage of the Cryptographic
Material for example by avoiding node exposed to the Internet to host
the Cryptographic Material. In addition, LURK provides means to
instantaneously suspend the delegation with a suspicious node. On the
other hand the LURK Extension 'tls12' introduces some latency, and is
not as scalable as STAR or delegated credential solutions. 

[](IB: a comparison should be made here)

The LURK Extension 'tls12' is seen as a complementary to the STAR and
"delegated credentials". The LURK Extension 'tls12' is a back end
solution that does not require any modifications from TLS Client or the
CA. It is also aimed at protecting the Cryptographic Material.

LURK may also be deployed within an administrative domain in order to to
provide a more controlled deployment of TLS Servers.

# Terminology and Acronyms

This document re-uses the terminology defined in
{{?I-D.mglt-lurk-lurk}}. 


# LURK Header {#sec-lurk-tls-header}

LURK / TLS 1.2 is a LURK Extension that introduces a new designation
"tls12". This document assumes that Extension is defined with
designation set to "tls12" and version set to 1. The LURK Extension
extends the LURKHeader structure defined in 
{{?I-D.mglt-lurk-lurk}} as follows:

~~~
enum {
    tls12 (1), (255)
} Designation;

enum {
   capabilities (0), ping (1), rsa_master (2), 
   rsa_extended_master (3), ecdhe (4), (255)
}TLS12Type;


enum {
    // generic values reserved or aligned with the 
    // LURK Protocol
    request (0), success (1), undefined_error (2),
    invalid_payload_format (3),

    // code points for rsa authentication
    invalid_key_id_type (4), invalid_key_id (5),
    invalid_tls_random (6), invalid_prf (7),
    invalid_encrypted_premaster (8) 

    //code points for ecdhe authentication
    invalid_ec_type (9), invalid_ec_curve (10), 
    invalid_poo_prf (11), invalid_poo (12), (255)
}TLS12Status

struct {
     Designation designation = "tls12";
     int8 version = 1;   
} Extension;

struct {
    Extension extension;
    select( Extension ){
        case ("tls12", 1):
            TLS12Type;
    } type;
    select( Extension ){
        case ("tls12", 1):
            TLS12Status;
    } status;
    uint64 id;
    unint32 length;
} LURKHeader;
~~~




# rsa_master

A exchange of type "rsa_master" enables the LURK Client to delegate the
RSA Key Exchange and authentication as defined in {{!RFC5246}}. The LURK
Server returns the master secret.

## Request Payload {#sec-rsa-master-req}

A rsa_master request payload has the following structure:

~~~
enum {
    sha256_32 (0), (255)
}KeyPairIdType;

struct {
    KeyPairIdType type;
    opaque data; // length defined by the type
} KeyPairID;

enum{
    sha256_null (0), sha256_sha256 (1) (255)
} PRFAlgorithm

struct {
    KeyPairID key_id;
    Random client_random;        // see RFC5246 section 7.4.1.2
    Random server_random;    
   PRFAlgorithm pfs; 
} TLS12Base;

struct {
    TLS12Base base;
    EncryptedPreMasterSecret  pre_master; 
                        // see RFC5246 section 7.4.7.1 
                        // Length depends on the key.
} TLS12RSAMasterRequestPayload;
~~~

  
key_id
: The identifier of the public key. This document defines sha256_32
format which takes the 32 first bits of the hash of the binary ASN.1 DER
representation of the public key using sha256. The binary representation
of RSA keys is described in {{!RFC8017}}. The binary representation of
ECC keys is the subjectPublicKeyInfo structure defined in {{!RFC5480}}.

pfs
: the one-way hash function (OWHF) used by LURK to implement Perfect Forward
Secrecy.

client_random 
: the random value associated to the TLS Client as defined in {{!RFC5246}}
Section 7.4.1.2.  
  
server_random 
: the random value associated to the TLS Server as defined
in {{!RFC5246}} Section 7.4.1.2.  

EncryptedPreMasterSecret : The encrypted master secret as defined in
{{!RFC5246}} Section 7.4.7.1. 


### Perfect Forward Secrecy {#sec-pfs}

This document defines a mechanism which using a function called  pfs, to
prevent an attacker to send a request to the LURK Server in such a way that the said attacker can obtain back the master secret for an 
old handshake. In other words, the use of this function (in the context of the exchanges made) helps prevent
a forward-secrecy attack on an  old TLS session using its handshake-data observed by the adversary.

At a high level, what we require from PFS is that, in a mathematical sense,  it is not invertible (i.e., that given PFS(S), it is computationally infeasible to find S) and that it is injective (i.e., it is at least computationally infeasible to find x different from y such that f(x) = f(y)). 
In the security considerations, we will detail this in  a  cryptographic sense.

OPTION1:
We require that the pfs function is a collision-resistant hash function (CHRF). 
By CRHF, we mean a one-way hash function (OWHF) which also has collision resistance; the latter means that
it is computationally infeasible to find any two inputs x1 and x2 such that pfs(x1) =pfs(x2).
By one-way hash function (OWHF) we mean, as standard, a hash function pfs that  satisfies preimage resistance and
2nd-preimage resistance. That is, given a hash value y, it is computationally infeasible to find an x
such that pfs(x) = y, and respectively--  given a value x1 and its hash
h (x1), it is computationally infeasible to find another x2 such that pfs(x2) = pfs(x1).

For the concrete use of our pfs funtions, let S be a fresh.
randomly picked value generated  by the LURK Server.
The value of server_random in
the TLS exchange is then equal to pfs(S), i.e., server_random=pfs(S).
Between the LURK Client  and the LURK Server only server-random is exchanged.
The LURK Server sends S to the Key Server, in the query.


A man-in-the-middle attacker observing the (plaintext) TLS handshake between a LURK Client  and the LURK Server does not see S, but 
only server-random.
The preimage resistance guaranted by the pfs makes it such that this man-in-the-middle cannot retrieve S out of the observed server-random.
As such, this man-in-the-middle attacker cannot query the  S corresponding to an (old) observed handshake to the Key Server.
Moreover,  the collision resistance guaranteed by  the pfs makes it such that if  the aforementioned man-in-the-middle 
cannot find S' such that pfs(S)=pfs(S').


[](IB: I think we should go with Option1, just that CRHF are more expensive than PRFs)
[](IB: see http://www.forth.gr/onassis/lectures/2010-06-28/presentations/The_cryptographic_hash_function_crisis_and_the_SHA_3_competition.pdf)

OPTION2:
We require that the pfs function is the instance of a pseudo random function (PRF), keyed on a key k  that the LURK server already
shares with the Key server. I.e., server_random=pfs_k(S).

The difference compared to Option1 is that if the man-in-the-middle (MiM) above does later corrupt the LURK server, then the MiM 
can retrieve K, find the old S and query the Key server  on such an old S. 
I.e., a man-in-the-middle who latter corrupt the LURK Server could break forward-secrecy  in the case of Option2. This cannot happen in the case of Option1.


  
The server_random MUST follow the structure of {{!RFC5246}} section
7.4.1.2, which carries the gmt_unix_time in the first four bytes. 
So, the ServerHello.random of the TLS exchange is derived from the
server_random of the LURK exchange as defined below: 

~~~
gmt_unix_time = server_random[0..3];
ServerHello.random = pfs( server_random + "tls12 pfs" );  
ServerHello.random[0..3] = gmt_unix_time;
~~~

[](IB: if pfs is a hash, I would do ServerHello.random[0..3] = gmt_unix_time; ServerHello.random[4..x] =  pfs( server_random + "tls12 pfs";) 

The operation MUST be performed by the LURK Server as well as the TLS
Server, upon receiving the master secret or the signature of the
ecdhe_params from the LURK Client.


## Response Payload {#sec-lurk-tls-rsa-master-resp}

The "rsa_master" response payload contains the master secret and has
the following structure:

~~~
struct {
    opaque master[0..47];
} TLS12RSAMasterResponsePayload;
~~~


### LURK Client Behavior
	
A rsa_master request is sent so the LURK Server can derive the master
secret used by the TLS session. Upon receipt of the master_secret the
Edge Server can generate the session keys and finish the TLS key
exchange protocol.

### LURK Server Behavior {#sec-tls-master-srv}

Upon receipt of a rsa_master request, the LURK Server proceeds
according to the following steps:

1. Checking TLS12Base:

    * a) The LURK Server checks the RSA key pair is available (key_id). If the
format of the key pair identifier is not understood, an
"invalid_key_id_type" error is returned.  If the designated key pair is
not available an "invalid_key_id" error is returned.

    * b) The LURK Server checks the length of the encrypted premaster
 secret and returns an "invalid_payload_format" error if the length
differs from the length of binary representation of the RSA modulus. 

    * d) The LURK Server MUST check the format of the server_random  and
more specifically checks the gmt_unix_time associated to the random is
acceptable. Otherwise it SHOULD return an "invalid_tls_random" error.
The value of the time window is implementation dependent and SHOULD be a
configurable parameters. The LURK Server MAY also check the
client_random. This should be considered cautiously as such check may
prevent TLS Clients to set a TLS session. client_random is generated by
the TLS Client whose clock might not be synchronized with the one of the
LURK Server or that might have a TLS implementations that does not
generate random based on gmt_unix_time. 

2. The LURK Server checks the pfs. If it does not support the
PFSAlgorithm, an "invalid_prf" error is returned.

3. The LURK Server computes the necessary ServerHello.random from the
server_random when applicable as described in {{sec-pfs}}.

4. The LURK Server decrypts the encrypted premaster secret as described
in {{!RFC5246}} section 7.4.7.1.  
[](IB confused about the above)
When a PKCS1.5 format error is
detected, or a mismatch between the TLS versions provided as input and
the one indicated in the encrypted premaster secret, the Key Server
returns a randomly generated master secret.
 
5. If the pre master is appropriately decrypted, then the master secret
is computed as described in {{!RFC5246}} section 8.1 using the
client_random, and the server_random provided by the LURK Client.


6. The LURK Server returns a master secret in a
TLS12RSAMasterResponsePayload. 

7. Error are expected to provide the LURK Client an indication of the
cause that resulted in the error. When an error occurs the LURK Server
MAY ignore the request, or provide more generic error codes such as
"undefined_error" or "invalid_format".

## rsa_extended_master

A exchange of type "rsa_extended_master" enables the LURK Client to
delegate
the RSA Key Exchange and authentication. The LURK Server returns the
extended master secret as defined in {{!RFC7627}}.

### Request Payload

The "rsa_extended_master" payload request has the following
structure: 

~~~
struct{
    KeyPairID key_id
    PRFAlgorithm prf              // see RFC5246 section 6.1
    opaque session_hash<2...2^16-2>   
    EncryptedPreMasterSecret  pre_master 
                                  // see RFC5246 section 7.4.7.1
}TLS12ExtendedMasterRSARequestPayload;
~~~

key_id, pfs, pre_master
: are defined in {{sec-rsa-master-req}}. 
  
session_hash
: The hash of the TLS handshake session as described in {{!RFC7627}}
section 3.

Note that as the server_random is not provided by the LURK Client, PFS
mechanisms does not apply here. 

## Response Payload

rsa_extended_master response payload has a similar structure as the
rsa_master response payload 
{{sec-lurk-tls-rsa-master-resp}}.


## LURK Client Behavior
	
A rsa_extended_master request is sent so the LURK Server can derive
the master secret used by the TLS session. Upon receipt of the
master_secret the Edge Server can generate the session keys and finish
the TLS key exchange protocol.

## LURK Server Behavior

The LURK Server proceeds as described in  {{sec-tls-master-srv}} except
that the generation of the extended master is processed as described in
{{!RFC7627}}.


# ecdhe" {#sec-ecdhe}

A exchange of type "ecdhe" enables the LURK Client to delegate the
ECDHE_RSA {{!RFC5246}} or the ECDHE_ECDSA {{!I-D.ietf-tls-rfc4492bis}}
authentication. 
        
## Request Payload {#sec-ecdhe-req}

The "ecdhe" request payload has the following structure:

~~~
enum { null(0), sha256_128(1), sha256_256(2),
(255) }POOPRF 

struct {
    POOPRF poo_prf;
    select( poo_prf) {
        case ( "null" ):
        case ( "sha256_128" or "sha256_256" ):
            ECPoint rG;  //I-D.ietf-tls-rfc4492bis section 5.4
            ECPoint tG;
    }
} TLS12POOParams;

struct {
    TLS12Base base;
    SignatureAndHashAlgorithm sig_and_hash  //RFC 5246 section 4.7
    ServerECDHParams ecdhe_params;  // I-D.ietf-tls-rfc4492bis section 5.4
    POOParams poo_params;
} TLS12ECDHERequestPayload;
~~~


 
base
: is defined in  {{sec-rsa-master-req}}. 

ecdhe_params
: contains as defined in {{!I-D.ietf-tls-rfc4492bis}} section 5.4, the
elliptic curve domain parameters associated with the ECDH public key
(defined by the ECParameters structure) and the ephemeral ECDH public
key (defined by the ECPoint structure).  The public key is also noted in
this document bG with b is a random secret generated by the LURK Client
and G the base point of the curve.

poo_params
: defines the necessary parameters to provide a proof of ownership of
the ECDHE private key.  This option is intended to prevent the LURK
Server to sign bytes that do not correspond to a ECDHE public key.
        

poo_prf
: pseudo random function used to generate the necessary randoms to proof
ownership of the private key.  This document defines sha256_128 and
sha256_256 which apply the sha256 hash function and respectively return
the 128 or 256 first bits of the resulting hash.


rG, tG
:  are necessary points to generate the proof of ownership. r is a
random number chosen by the LURK Client. G is the the base point of the
curve. t = cb + r, with c a number that is not under the control of the
LURK Client generated as the output of poo_prf and b the random secret
of the private key. 


The proof of ownership consists in the LURK Client proving the knowledge
of the private random b, while not disclosing b.

c MUST NOT be under the control of the LURK Client. To achieve that
goal, c is generated as described below:

~~~
c = poo_prf ( base + ecdhe_params + "tls12 poo")  
~~~

The LURK Client computes t = cb + r and sends rG, tG, in poo_params
and bG in the ecdhe_params

The LURK Server computes c(bG) + rG and compares the output with tG.
The equality proves the ownership of b by the LURK Client. 

Note r and c may be treated as “very short-term secrets” but MUST remain
non-predictable. It is RECOMMENDED to use a length equivalent to the
expected level of security, that is 128 bit length (resp. 256 bit
length) for a 128 (resp 256) bit security level. Given b, we RECOMMEND r
and c to be at least half the size of b. 


## Response Payload

The "ecdhe" response payload has the following structure:

~~~
struct {
    Signature signed_params;  // I-D.ietf-tls-rfc4492bis section 5.4  
} TLS12ECDHEResponsePayload;
~~~

signed_params
: signature applied to the hash of the
ecdhe_params
as well as client_random and server_random as described in  
{{!I-D.ietf-tls-rfc4492bis}} section 5.4.

### LURK Client Behavior

The LURK Client builds the base as described in 
{{sec-rsa-master-req}}. The LURK Client computes c, t, rG and tG
as described in {{sec-ecdhe-req}}.


Upon receiving the response payload, the LURK Client MAY check the
signature. If the signature does not match an error SHOULD be
reported. 
     

### LURK Server Behavior

Upon receiving an ecdhe request, the LURK Server proceeds as follows:

1. The LURK Server performs some format check of the ecdhe_params before
signing them. If the ecdhe_params does not follow the expected
structure. With the notations from {{!I-D.ietf-tls-rfc4492bis}}, if
curve_type is not set to "named_curve", the LURK Server SHOULD respond
with an "invalid_ec_type" error.  If the curve or namedcurve is not
supported the LURK Server SHOULD be able to respond with an
"invalid_ec_curve" error. 

2. The LURK Server processes the poo_params. If the poo_prf is not
supported, the LURK Extension returns a "invalid_poo_prf" status. If
poo_prf is supported and different from "null", the LURK Server proceeds
to the proof of ownership as described in {{sec-ecdhe-req}}. If the
proof is not properly verified, the LURK Extension returns a
"invalid_poo" status.

3. The LURK Server processes the base structure as described in
{{sec-tls-master-srv}}

4. The LURK Server generates the siged_params.

Error are expected to provide the LURK Client an indication of the cause
that resulted in the error. When an error occurs the LURK Server MAY
ignore the request, or provide more generic error codes such as
"undefined_error" or "invalid_format".

# capabilities

A exchange of type "capabilities" enables the LURK Client to be informed
of the supported operations performed by the LURK Server. The supported
parameters are provided on a per type basis.


## Request Payload
        
A LURK "capabilities" request has no payload.
        
## Response Payload
	
The "capabilities" response payload lists for each supported type, the
supported certificates, the supported signatures and hash associated.
The "capabilities" payload has the following structure:

~~~

struct {
     KeyPairID key_id_type_list<0..255>; 
     PFSAlgorithmList pfs_list<0..255>
     Certificate certificate_list  
} TLS12RSACapability; 



struct { 
    TLS12RSACapability rsa_cap;
    SignatureAndHashAlgorithm sig_and_hash_list<0..255>
    NameCurve ecdsa_curves_list<0..255>; 
    NameCurve ecdhe_curves_list<0..255>
    POOPRF poo_prf_list<0..255>
} TLS12ECDHECapability;  

struct {
    uint32 length;
    TLS12Type type
    Select( type ) {
           case rsa_master : TLS12RSACapability,
           case rsa_extended_master : TLS12RSACapability,
           case ecdhe : TLS12ECDHECapability
    } capability ;
} TLS12Capability 


struct {
    TLS12Capability capability_list;
    opaque state<32>;  
} TLS12CapabilitiesResponsePayload;
~~~

key_id_type_list
: the supported key_id_type.

pfs_list
: designates the list of pfs ( see {{sec-rsa-master-req}}). 

certificate_list
: designates the certificates associated to message type. The format is
defined in {{?I-D.ietf-tls-tls13}} in section 4.4.2. This format enables
the use of X509 as well as Raw Public key, while the Certificate
structure defined in {{!RFC5246}} section 7.4.2 does not.
  
sig_and_hash_list 
: designates supported signature algorithms as well as PRF used for the
different operations. The format is defined in {{!RFC5246}} section
7.4.1.4.1.

ecdsa_curves_list
: the supported signatures 

ecdhe_curves_list
: the supported curves for ECHDE parameters.

poo_prf_list
: the supported message type poo_prf ( see {{sec-ecdhe-req}}. to be used
with the proof of ownership.

type_list
: the supported message type of the LURK extension.

state
: characterizes the configuration associated to 'tls12' on the LURK
Server..


### LURK Client Behavior

The LURK Client performs a capability request in order to determine
the possible operations. 

The LURK Client is expected to keep the state value to be able to
detect a change in the LURK Server configuration when an error
occurs. 


### LURK Server Behavior"

Upon receiving a capabilities request, the LURK Extension MUST return
the capabilities payload associated to a "success" status to the LURK
Server. These information are then forwarded by the LURK Server to the
LURK Client.


# ping

A exchange of type "ping" enables the LURK Client to check the 
reachability in a context of the defined LURK Extension.

## Request Payload

A "ping" request has no payload.

## Response Payload

A "ping" response has no payload.

### LURK Client Behavior
        
The LURK Client sends a "ping" request to test the reachability of
the LURK Server. The reachability is performed for the tls12 LURK
Extension.
        

### LURK Server Behavior

Upon receiving a ping request, the LURK Extension MUST return the
ping response associated with a "success" status to the LURK Server.
These information are then forwarded by the LURK Server to the LURK
Client. 


# Security Considerations {#sec-sec}

The security considerations defined in 
{{?I-D.mglt-lurk-lurk}} applies to the LURK Extension "tls12"
defined in this document.

A comparison with STAR {{?I-D.ietf-acme-star}} 
and {{?I-D.sheffer-acme-star-request}} from a security-viewpoint is pending.

# 1. General Considerations

[](IB: I am not so sure about this)
The LURK Extension "tls12" is expected to have response smaller that
the request or at least not significantly larger, which makes
"tls12" relatively robust to amplification attacks.

The LURK Extension "tls12" performs cryptographic operations that may
lead to resource exhaustion, as such it is RECOMMENDED the LURK Server
authenticates the LURK Clients. In addition, this prevents when UDP is
used the LURK Server to be used as a reflector.

  
In LURK, the rsa_master and rsa_extended_master returns the master_secret
instead of the premaster, unlike in standard TLS handshakes.
Note that this not stop session resumption and there is therefore a risk 
that a rogue LURK client may still be able to run resumed handshakes with client
without the ability that decomissioning it can stop him.


# 2. Perfect Forward Secrecy Considerations

The rsa_master and ecdhe exchange provides a mechanism to provide
Perfect Forward Secrecy modulo some cryptographic assumptions and some attacker  
model as detailed below. The former case, rsa_master, achieves this in a non-standard way 
and we detail this more below.

The rsa_extended_master does not provide PFS mechanism as a digest of
the TLS Key Exchange is provided which prevent the LURK Server to
perform an agreed operation on the HelloServer.random. 

rsa_master and ecdhe request provides client_random. In order to
limit the replay of a random value it RECOMMENDED the Server control the
time at which the random has been generated. The time control should
also consider desynchronization between the TLS Client and the LURK
Server.  

### The  RSA-mode Case

Recall that, this document  modifies the way the server-random  is generated 
on the LURK client (e.g., the egde server). Namely, this is as follows. 
S is a randomly generated by the Lurk Client (e.g., the edge server) and pfs is a function. 
The value of server_random in
the TLS exchange is then equal to pfs(S), i.e., server_random=pfs(S).
Between the LURK Client  and the LURK Server only server-random is exchanged.
The LURK Client (e.g, edge server) sends S to the Lurk Server (e.g., key serveer), in its handshake query.

At a high level, what we required from PFS is that, in a mathematical sense,  it is not invertible (i.e., that given PFS(S), it is computationally infeasible to find S) and that it is injective (i.e., it is at least computationally infeasible to find x different from y such that f(x) = f(y)). 
Now we will detail this in  a  cryptographic sense.

The pfs function was introduced to 
prevent an attacker to send a request to the LURK Server in such a way that the said attacker can obtain back the master secret for an 
old handshake. In other words, the use of this function (in the context of the exchanges made) helps prevent
a forward-secrecy attack on an  old TLS session using its handshake-data observed by the adversary.

Now we detail what pfs can be instantiated with to attain security against the above. We give two options.

- OPTION1:
We require that the pfs function is a collision-resistant hash function (CHRF). 
By CRHF, we mean a one-way hash function (OWHF) which also has collision resistance; the latter means that
it is computationally infeasible to find any two inputs x1 and x2 such that pfs(x1) =pfs(x2).
By one-way hash function (OWHF) we mean, as standard, a hash function pfs that  satisfies preimage resistance and
2nd-preimage resistance. That is, given a hash value y, it is computationally infeasible to find an x
such that pfs(x) = y, and respectively--  given a value x1 and its hash
h (x1), it is computationally infeasible to find another x2 such that pfs(x2) = pfs(x1).


A man-in-the-middle attacker observing the (plaintext) TLS handshake between a LURK Client  and the LURK Server does not see S, but 
only server-random.
The preimage resistance guaranted by the pfs makes it such that this man-in-the-middle cannot retrieve S out of the observed server-random.
As such, this man-in-the-middle attacker cannot query the  S corresponding to an (old) observed handshake to the Key Server.
Moreover,  the collision resistance guaranteed by  the pfs makes it such that if  the aforementioned man-in-the-middle 
cannot find S' such that pfs(S)=pfs(S').

- OPTION2:
We require that the pfs function is the instance of a pseudorandom function (PRF), keyed on a key k  that the LURK server already
shares with the Key server. I.e., server_random=pfs_k(S).

The difference compared to Option1 is that if the man-in-the-middle (MiM) above does later corrupt the LURK server, then the MiM 
can retrieve K, find the old S and query the Key server  on such an old S. 
I.e., a man-in-the-middle who latter corrupt the LURK Server could break forward-secrecy  in the case of Option2. This cannot happen in the case of Option1.

However, we offer this Option2 alongside Option1 (even though it is a weaker solution for security against a MiM + corrupt LURK Client) because  CRHF can be more expensive than PRFs.


### The ECDHE Case

As previously mentioned, the LURK Server may be used as signing
oracle for the specific string by a corrupt LURK Client:

~~~
    SHA(ClientHello.random + ServerHello.random +
                         ServerKeyExchange.params);  
~~~

More specifically, the ECDHE_RSA and ECDHE_DSA mechanisms does not
associate the signature to a TLS1.2 context. As a result, the signature
could be re-used in another context.


The attacker may also given a clear text to be signed, generate a
collision such that a collision occurs which provides is related to the
second pre-image and collision resistance property of the hash
function.

The surface of attack is limited by:

* limiting the possibility of aggregating a collection of clear text
and their corresponding signatures. This could be achieved by using
corruptint multiple LURK Clients.

* increasing the checks and ensure that signature is performed in a TLS
1.2 context. For that purpose it is RECOMMENDED the LURK Server checks
the consistency of its input parameters. This includes the proof of
ownership as well as the format of the randoms and ecdhe_params for
example.

* limiting the usage of a Cryptographic material to a single usage, in
our case serving  TLS 1.2. 



## 3. Proxied-Infrastructure Considerations

### 3.1. Client's Finished checked to LURK Server

To ensure  audit powers by the LURK Server, as it is arguably 
good to do in proxied infrastructures, we RECOMMEND that the Client's Finished be sent 
by the LURK Client to the LURK Server, along with all options etc of the hanshake. 
To this end, the LURK Server can check the content of the Client's Finished  against 
the handshake data and be more assured of the legitimacy of the query.

This is a measure proposed by
BHARGAVAN, K., BOUREANU, I., FOUQUE, P-A., et al. in "Content delivery over TLS: A cryptographic analysis of keyless SLL". In  IEEE European Symposium on Security and Privacy (EuroS&P),  2017. p. 1-16.


### 3.2. LURK Server to send material for server-random to LURK Client (RSA mode)

The LURK  Server (e.g, the key server) can provide to the LURK client (e.g., edge server) the value S for 
the LURK Client to compute  server-random as PFS(S).

In this case, later in the handshake, the LURK Client does not have to include S in the query.
In this way, the man-in-the-middle attacker + corrupted LURK Client cannot mount a perfect 
forward secrecy attack by querying data from an old query. It also gives the LURK server 
more audit power (i.e., the server-random checked against the Client Finished can also be 
checked against the locally generated S).
However, this option is more costly (i.e., causing more latency), since it involves the LURK  Server 
in the initial part of the handshake, where the server-random is generated. 


# IANA Considerations

The requested information is defined  in {{?I-D.mglt-lurk-lurk}}.

LURK Extension Designation: tls12 
LURK Extension Reference: [RFD-TBD]
LURK Extension Description: RSA, ECDHE_RSA and ECDHE_ECDSA for (D)TLS
1.2.

    LURK tls12 Extension Status 
    
    Value    Description                 Reference
    ---------------------------------------------------
    0 - 1    Reserved                    [RFC-TBD-LURK]
    2        undefined_error             [RFC-TBD]
    3        invalid_payload_format      [RFC-TBD]
    4        invalid_key_id_type         [RFC-TBD]
    5        invalid_key_id              [RFC-TBD]
    6        invalid_tls_random          [RFC-TBD]
    7        invalid_prf                 [RFC-TBD]
    8        invalid_encrypted_premaster [RFC-TBD]
    9        invalid_ec_type             [RFC-TBD]
    10       invalid_ec_curve            [RFC-TBD]
    11       invalid_poo_prf             [RFC-TBD]
    12       invalid_poo                 [RFC-TBD]
    13 - 255 UNASSIGNED                 
    
    LURK tls12 Extension Type 
    
    Value    Description         Reference
    ----------------------------------------------
    0        capabilities        [RFC-TBD]
    1        ping                [RFC-TBD]
    2        rsa_master          [RFC-TBD]
    3        rsa_extended_master [RFC-TBD]
    4        ecdhe               [RFC-TBD]
    16 - 255 UNASSIGNED                  



# Acknowledgments
      
We would like to thank for their very useful feed backs: Yaron
Sheffer, Yoav Nir, Stephen Farrell, Eric Burger, Thomas Fossati, Eric
Rescorla Mat Naslung, Rich Salz. Many ideas in this document are from
{{?I-D.erb-lurk-rsalg}}.

We would also like to thank those that have supported LURK or raised
interesting discussions. This includes among others Robert Skog, Hans
Spaak, Salvatore Loreto, John Mattsson, Alexei Tumarkin, Yaron Sheffer,
Richard Brunner, Stephane Dault, Dan Kahn Gillmor, Joe Hildebrand,
Kelsey Cairns.  


# Apendix
## LURK Exchange for TLS RSA Master Secret 

    TLS Client          Edge Server         Key Server
    
    ClientHello
       server_version  
       client_random         
       cipher_suite 
           TLS_RSA_*, ... 
    --------> 
                        S = server_random                          
                        server_random = pfs( S )

                        ServerHello
                            tls_version  
                            server_random        
                            Cipher_suite=TLS_RSA 
                        Certificate
                            RSA Public Key
                        ServerHelloDone
                        <-------- 
    
    ClientKeyExchange
        EncryptedPremasterSecret 
    [ChangeCipherSpec]
    Finished              
    -------->  
    
    
                        TLS12 Request Header
                        TLS12MasterRSARequestPayload
                            key_id
                            client_random
                            S
                            pfs
                            EncryptedPremasterSecret    
                        -------->
    
                                     server_random = pfs( S )

                                     master_secret = PRF(\
                                     pre_master_secret + \
                                     "master secret" +\
                                     client_random +\
                                     server_random)[0..47];
        
                                            TLS12 Response Header
                                            TLS12MasterResponsePayload
                                                master         
                                            <--------          
    
                        [ChangeCipherSpec]
                            Finished
                        <--------
    Application Data      <------->     Application Data

## LURK Exchange for TLS RSA Extended Master Secret 

    TLS Client          Edge Server         Key Server
    
    ClientHello 
       tls_version  
       cipher_suite 
           TLS_RSA_*, ... 
       Extension 0x0017 
    --------> 
       
                        ServerHello
                            edge_server_version  
                            cipher_suite=TLS_RSA 
                            Extension 0x0017
                        Certificate
                            RSA Public Key
                        ServerHelloDone
                        <-------- 
    ClientKeyExchange
        EncryptedPremasterSecret 
    [ChangeCipherSpec]
    Finished        
    -------->  
                           
                        TLS12 Request Header
                        TLS12ExtendedMasterRSAInputPayload
                            key_id
                            tls_version
                            master_prf
                            session_hash           
                            EncryptedPreMasterSecret  
                        -------->
    
                                     1. Computing Master Secret
                                     master_secret = master_prf(
                                     pre_master_secret +\
                                     "extended master secret" +\
                                     session_hash)[0..47]
    
                                            TLS12 Response Header
                                            TLS12MasterPayload
                                                master         
                                            <--------          
    
                        [ChangeCipherSpec]
                            Finished
                        <--------
    Application Data      <------->     Application Data

## LURK Exchange for TLS ECDHE Signature

    TLS Client          Edge Server         Key Server
    
    ClientHello
       tls_version  
       client_random         
       cipher_suite 
           TLS_ECDHE_ECDSA_*, TLS_ECDHE_RSA_*, ... 
           Extension Supported EC, Supported Point Format
    --------> 
                        S = server_random                          
                        server_random = pfs( S )
       
                        TLS12 Request Header
                        TLS12ECDHEInputPayload
                            key_id
                            client_random
                            S
                            ecdhe_params     
                        -------->
                                     server_random = pfs( S )

                                     signature = ECDSA( client_random +\
                                     server_random + ecdhe_params )
    
                                            TLS12 Response Header
                                            TLS12DigitallySignedPayloads
                                                signature
                                            <--------          
    
                        ServerHello
                            tls_version  
                            server_random         
                            Cipher_suite=TLS_ECDHE_ECDSA 
                            Extension Supported EC, 
                            Supported Point Format
                        Certificate
                            ECDSA Public Key
                        ServerKeyExchange
                            ecdhe_params
                            signature
                        ServerHelloDone
                        <--------
    
    
    ClientKeyExchange
    [ChangeCipherSpec]
    Finished              
    -------->
                        [ChangeCipherSpec]
                        Finished
                        <--------
    Application Data      <------->     Application Data

